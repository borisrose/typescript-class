<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><title>Améliorer la POO avec TypeScript</title><link rel="stylesheet" href="node_modules/reveal.js/dist/reset.css"><link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css"><link rel="stylesheet" href="node_modules/reveal.js/dist/theme/black.css" id="theme"><!--This CSS is generated by the Asciidoctor reveal.js converter to further integrate AsciiDoc's existing semantic with reveal.js--><style type="text/css">.reveal div.right {
  float: right
}

/* source blocks */
.reveal .listingblock.stretch > .content {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre > code {
  height: 100%;
  max-height: 100%
}

/* auto-animate feature */
/* hide the scrollbar when auto-animating source blocks */
.reveal pre[data-auto-animate-target] {
  overflow: hidden;
}

.reveal pre[data-auto-animate-target] code {
  overflow: hidden;
}

/* add a min width to avoid horizontal shift on line numbers */
code.hljs .hljs-ln-line.hljs-ln-n {
  min-width: 1.25em;
}

/* tables */
table {
  border-collapse: collapse;
  border-spacing: 0
}

table {
  margin-bottom: 1.25em;
  border: solid 1px #dedede
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
  padding: .5em .625em .625em;
  font-size: inherit;
  text-align: left
}

table tr th, table tr td {
  padding: .5625em .625em;
  font-size: inherit
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
  display: table-cell;
  line-height: 1.6
}

td.tableblock > .content {
  margin-bottom: 1.25em
}

td.tableblock > .content > :last-child {
  margin-bottom: -1.25em
}

table.tableblock, th.tableblock, td.tableblock {
  border: 0 solid #dedede
}

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock {
  border-width: 0 1px 1px 0
}

table.grid-all > tfoot > tr > .tableblock {
  border-width: 1px 1px 0 0
}

table.grid-cols > * > tr > .tableblock {
  border-width: 0 1px 0 0
}

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock {
  border-width: 0 0 1px
}

table.grid-rows > tfoot > tr > .tableblock {
  border-width: 1px 0 0
}

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child {
  border-right-width: 0
}

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock {
  border-bottom-width: 0
}

table.frame-all {
  border-width: 1px
}

table.frame-sides {
  border-width: 0 1px
}

table.frame-topbot, table.frame-ends {
  border-width: 1px 0
}

.reveal table th.halign-left, .reveal table td.halign-left {
  text-align: left
}

.reveal table th.halign-right, .reveal table td.halign-right {
  text-align: right
}

.reveal table th.halign-center, .reveal table td.halign-center {
  text-align: center
}

.reveal table th.valign-top, .reveal table td.valign-top {
  vertical-align: top
}

.reveal table th.valign-bottom, .reveal table td.valign-bottom {
  vertical-align: bottom
}

.reveal table th.valign-middle, .reveal table td.valign-middle {
  vertical-align: middle
}

table thead th, table tfoot th {
  font-weight: bold
}

tbody tr th {
  display: table-cell;
  line-height: 1.6
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
  font-weight: bold
}

thead {
  display: table-header-group
}

.reveal table.grid-none th, .reveal table.grid-none td {
  border-bottom: 0 !important
}

/* kbd macro */
kbd {
  font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
  display: inline-block;
  color: rgba(0, 0, 0, .8);
  font-size: .65em;
  line-height: 1.45;
  background: #f7f7f7;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  border-radius: 3px;
  -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em white inset;
  box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em #fff inset;
  margin: 0 .15em;
  padding: .2em .5em;
  vertical-align: middle;
  position: relative;
  top: -.1em;
  white-space: nowrap
}

.keyseq kbd:first-child {
  margin-left: 0
}

.keyseq kbd:last-child {
  margin-right: 0
}

/* callouts */
.conum[data-value] {
  display: inline-block;
  color: #fff !important;
  background: rgba(0, 0, 0, .8);
  -webkit-border-radius: 50%;
  border-radius: 50%;
  text-align: center;
  font-size: .75em;
  width: 1.67em;
  height: 1.67em;
  line-height: 1.67em;
  font-family: "Open Sans", "DejaVu Sans", sans-serif;
  font-style: normal;
  font-weight: bold
}

.conum[data-value] * {
  color: #fff !important
}

.conum[data-value] + b {
  display: none
}

.conum[data-value]:after {
  content: attr(data-value)
}

pre .conum[data-value] {
  position: relative;
  top: -.125em
}

b.conum * {
  color: inherit !important
}

.conum:not([data-value]):empty {
  display: none
}

/* Callout list */
.hdlist > table, .colist > table {
  border: 0;
  background: none
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
  background: none
}

td.hdlist1, td.hdlist2 {
  vertical-align: top;
  padding: 0 .625em
}

td.hdlist1 {
  font-weight: bold;
  padding-bottom: 1.25em
}

/* Disabled from Asciidoctor CSS because it caused callout list to go under the
 * source listing when .stretch is applied (see #335)
 * .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} */
.colist td:not([class]):first-child {
  padding: .4em .75em 0;
  line-height: 1;
  vertical-align: top
}

.colist td:not([class]):first-child img {
  max-width: none
}

.colist td:not([class]):last-child {
  padding: .25em 0
}

/* Override Asciidoctor CSS that causes issues with reveal.js features */
.reveal .hljs table {
  border: 0
}

/* Callout list rows would have a bottom border with some reveal.js themes (see #335) */
.reveal .colist > table th, .reveal .colist > table td {
  border-bottom: 0
}

/* Fixes line height with Highlight.js source listing when linenums enabled (see #331) */
.reveal .hljs table thead tr th, .reveal .hljs table tfoot tr th, .reveal .hljs table tbody tr td, .reveal .hljs table tr td, .reveal .hljs table tfoot tr td {
  line-height: inherit
}

/* Columns layout */
.columns .slide-content {
  display: flex;
}

.columns.wrap .slide-content {
  flex-wrap: wrap;
}

.columns.is-vcentered .slide-content {
  align-items: center;
}

.columns .slide-content > .column {
  display: block;
  flex-basis: 0;
  flex-grow: 1;
  flex-shrink: 1;
}

.columns .slide-content > .column > * {
  padding: .75rem;
}

/* See #353 */
.columns.wrap .slide-content > .column {
  flex-basis: auto;
}

.columns .slide-content > .column.is-full {
  flex: none;
  width: 100%;
}

.columns .slide-content > .column.is-four-fifths {
  flex: none;
  width: 80%;
}

.columns .slide-content > .column.is-three-quarters {
  flex: none;
  width: 75%;
}

.columns .slide-content > .column.is-two-thirds {
  flex: none;
  width: 66.6666%;
}

.columns .slide-content > .column.is-three-fifths {
  flex: none;
  width: 60%;
}

.columns .slide-content > .column.is-half {
  flex: none;
  width: 50%;
}

.columns .slide-content > .column.is-two-fifths {
  flex: none;
  width: 40%;
}

.columns .slide-content > .column.is-one-third {
  flex: none;
  width: 33.3333%;
}

.columns .slide-content > .column.is-one-quarter {
  flex: none;
  width: 25%;
}

.columns .slide-content > .column.is-one-fifth {
  flex: none;
  width: 20%;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.text-left {
  text-align: left !important
}

.text-right {
  text-align: right !important
}

.text-center {
  text-align: center !important
}

.text-justify {
  text-align: justify !important
}

.footnotes {
  border-top: 1px solid rgba(0, 0, 0, 0.2);
  padding: 0.5em 0 0 0;
  font-size: 0.65em;
  margin-top: 4em;
}

.byline {
  font-size:.8em
}
ul.byline {
  list-style-type: none;
}
ul.byline li + li {
  margin-top: 0.25em;
}
</style><link rel="stylesheet" href="styles.css"></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Améliorer la POO avec TypeScript</h1></section><section id="_les_rappels_des_pattern_poo_singleton_factory" class="blue background"><h2>Les rappels des Pattern POO : Singleton, Factory</h2><div class="slide-content"><div class="paragraph"><p>Vu précédemment</p></div></div></section>
<section id="_lusage_des_interfaces_typescript_duck_typing" class="blue background"><h2>L&#8217;usage des interfaces TypeScript : "Duck Typing"</h2><div class="slide-content"><div class="paragraph"><p>Vu précédemment</p></div></div></section>
<section><section id="_les_classes_et_les_interfaces" class="blue background"><h2>Les classes et les interfaces</h2><div class="slide-content"><div class="paragraph"><p>TypeScript gère intégralement le mot clé class introduit dans EMACScript 2015</p></div><div class="paragraph"><p>Il ajoute des annotations de type et d&#8217;autres syntaxes pour nous permettre d&#8217;exprimer les relations entre des classes et d&#8217;autres types.</p></div></div></section><section id="_les_membres_dune_classe" class="yellow background"><h2>Les membres d&#8217;une classe</h2></section><section id="_une_classe_vide" class="yellow background"><h2>Une classe vide</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Point {}</code></pre></div></div>
<div class="paragraph"><p>Pour l&#8217;instant cette classe est inutile donc on va lui ajouter des membres.</p></div></div></section><section id="_des_champs_fields" class="yellow background"><h2>Des champs (fields)</h2><div class="slide-content"><div class="paragraph"><p>Une déclaration de champs crée un propriété publique accessible en écriture sur la classe</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Point {
  x: number;
  y: number;
}


const pt = new Point();
pt.x = 0;
pt.y = 0;</code></pre></div></div></div></section><section id="_observations" class="yellow background"><h2>Observations</h2><div class="slide-content"><div class="paragraph"><p>Comme partout ailleurs, les annotations de type sont optionnelles, mais implicitement ce sera un type any si rien n&#8217;est spécifié.</p></div>
<div class="paragraph"><p>Les champs peuvent avoir des initialisateurs. Ils vont s&#8217;exécuter automatiquement au moment de l&#8217;instantiation de la classe.</p></div></div></section><section id="_exemple" class="green background"><h2>Exemple</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Point {
  x = 0;
  y = 0;
}

const pt = new Point();
// Prints 0, 0
console.log(`${pt.x}, ${pt.y}`);</code></pre></div></div>
<div class="paragraph"><p>Comme avec const, let et var, l&#8217;initialisateur de propriété d&#8217;une classe va être utilisé pour inférer son type.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">const pt = new Point();
pt.x = "0";
Type 'string' is not assignable to type 'number'.</code></pre></div></div></div></section><section id="_strictpropertyinitialization" class="yellow background"><h2>--strictPropertyInitialization</h2><div class="slide-content"><div class="paragraph"><p>Le paramètre  strictPropertyInitialization contrôle si les champs d&#8217;une classe doivent être initialisés dans le constructeur.</p></div></div></section><section id="_démonstration" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class BadGreeter {
  name: string;
    //Property 'name' has no initializer and is not definitely assigned in the constructor.
}

class GoodGreeter {
  name: string;

  constructor() {
    this.name = "hello";
  }
}</code></pre></div></div></div></section><section id="_observations_2" class="yellow background"><h2>Observations</h2><div class="slide-content"><div class="paragraph"><p>Il faut noter que le champ doit être initialisé dans dans le constructeur.</p></div>
<div class="paragraph"><p>TS n&#8217;analyse pas les méthodes qu&#8217;on invoque depuis le constructeur pour détecter si il y a une initialisation ou pas.</p></div>
<div class="paragraph"><p>Il ne fait pas cela car une classe dérivée pourrait courcircuiter ces méthodes et échouer à initialiser les membres.</p></div></div></section><section id="_intations" class="yellow background"><h2>Intations</h2><div class="slide-content"><div class="paragraph"><p>Si vous avez l&#8217;intention d&#8217;initialiser un champ via un moyen différent que le constructeur par exemple via une bibliothèque externe qui complèterait une partie de votre classe pour vous, vous pouvez utiliser l&#8217;opérateur d&#8217;assertion d&#8217;assignation absolue !:</p></div></div></section><section id="_démonstration_2" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class OKGreeter {
  // Not initialized, but no error
  name!: string;
}</code></pre></div></div></div></section></section>
<section><section id="_readonly" class="blue background"><h2>readonly</h2><div class="slide-content"><div class="paragraph"><p>Les champs peuvent être préfixés par le modificateur readonly.
Cela empêche des assignations de valeur pour ce champ en dehors du constructeur.</p></div></div></section><section id="_exemple_2" class="green background"><h2>Exemple</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Greeter {
  readonly name: string = "world";

  constructor(otherName?: string) {
    if (otherName !== undefined) {
      this.name = otherName;
    }
  }

  err() {
    this.name = "not ok";
//Cannot assign to 'name' because it is a read-only property.
  }
}


const g = new Greeter();
g.name = "also not ok";
//Cannot assign to 'name' because it is a read-only property.</code></pre></div></div></div></section></section>
<section><section id="_constructors" class="blue background"><h2>Constructors</h2><div class="slide-content"><div class="paragraph"><p>Les constructeurs de classe sont très semblables aux fonctions. Vous pouvez ajouter des paramètres avec des annotations de type, des valeurs par défaut et des surcharges (overloads)</p></div></div></section><section id="_démonstration_3" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Point {
  x: number;
  y: number;

  // Normal signature with defaults
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
}


class Point {
  // Overloads
  constructor(x: number, y: string);
  constructor(s: string);
  constructor(xs: any, y?: any) {
    // TBD
  }
}</code></pre></div></div></div></section><section id="_les_différences_entre_la_signature_dun_constructeur_et_celle_dune_fonction" class="yellow background"><h2>Les différences entre la signature d&#8217;un constructeur et celle d&#8217;une fonction</h2><div class="slide-content"><div class="paragraph"><p>Les constructuers ne peuvent pas avec de paramètres de type, ceux-là appartiennent à la déclaration de classe extérieure.</p></div>
<div class="paragraph"><p>Les constructuers ne peuvent pas avoir pas avoir d&#8217;annotion de type pour la valeur retournée. Le type de l&#8217;instance de la classe est toujours ce qui est retourné.</p></div></div></section><section id="_super_calls" class="yellow background"><h2>Super Calls</h2><div class="slide-content"><div class="paragraph"><p>Comme en JavaScript, si vous avez une classe de base, (une classe mère), vous aurez besoin d&#8217;appeler super() dans le corps de votre constructeur avant de pouvoir utiliser un membre this.</p></div></div></section><section id="_démonstration_4" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Base {
  k = 4;
}

class Derived extends Base {
  constructor() {
    // Prints a wrong value in ES5; throws exception in ES6
    console.log(this.k);
//'super' must be called before accessing 'this' in the constructor of a derived class.
    super();
  }
}</code></pre></div></div>
<div class="paragraph"><p>Oublier d&#8217;appeler super est une erreur facile à faire en JS, mais TS vous dira quand c&#8217;est nécessaire.</p></div></div></section><section id="_méthodes" class="yellow background"><h2>Méthodes</h2><div class="slide-content"><div class="paragraph"><p>Une proprité fonction sur une classe est appelée une méthode . Les méthodes peuvent utiliser les mêmes types d&#8217;annotation de types que les fonctions et les constructeurs.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Point {
  x = 10;
  y = 10;

  scale(n: number): void {
    this.x *= n;
    this.y *= n;
  }
}</code></pre></div></div></div></section><section id="_explication" class="yellow background"><h2>Explication</h2><div class="slide-content"><div class="paragraph"><p>A l&#8217;intérieur du corps de la méthode, c&#8217;est encore obligatoire d&#8217;accéder aux champs et autres méthodes via this.</p></div>
<div class="paragraph"><p>Un nom non qualifié dans le coprs de la méthode fera toujours référence à quelque chose dans le scope l&#8217;entourant</p></div></div></section><section id="_démonstration_5" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">let x: number = 0;

class C {
  x: string = "hello";

  m() {
    // This is trying to modify 'x' from line 1, not the class property
    x = "world";
Type 'string' is not assignable to type 'number'.
  }
}</code></pre></div></div></div></section><section id="_getters_setters" class="yellow background"><h2>Getters / Setters</h2><div class="slide-content"><div class="paragraph"><p>Les classes aussi peuvent avoir des accesseurs</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class C {
  _length = 0;

  get length() {
    return this._length;
  }

  set length(value) {
    this._length = value;
  }

}</code></pre></div></div></div></section><section id="_observations_3" class="yellow background"><h2>Observations</h2></section><section id="_utilité_de_lutilisateur_de_get_et_set" class="yellow background"><h2>Utilité de l&#8217;utilisateur de get et set</h2><div class="slide-content"><div class="paragraph"><p>Il faut noter qu&#8217;une paire get/set soutant un champ sans logique en plus est très rare en JS.</p></div>
<div class="paragraph"><p>Il est bon d&#8217;exposer les champs publics si vous n&#8217;avez pas besoin d&#8217;ajouter de logique additionnelle durant les opérations get/set.</p></div></div></section><section id="_les_règles_dinférence_des_accesseurs" class="yellow background"><h2>Les règles d&#8217;inférence des accesseurs</h2><div class="slide-content"><div class="paragraph"><p>TS a d&#8217;ialleurs des règles d&#8217;inférences spciales concernant les accesseurs.</p></div>
<div class="paragraph"><p>Si gets se termine (exists) mais pas set, la propriété est automatiquement en "readonly".</p></div>
<div class="paragraph"><p>Si le type du paramètre set n&#8217;est pas spécifié, il est déduit du type retourné par l&#8217;accesseur.</p></div>
<div class="paragraph"><p>Les Getters et Setter doivent avoir la même visibilité de membre.</p></div></div></section><section id="_nouveauté_ts_4_3" class="yellow background"><h2>Nouveauté TS 4.3</h2><div class="slide-content"><div class="paragraph"><p>Quoique depuis TS 4.3 il est possible d&#8217;avoir des accesseurs avec différents types pour l&#8217;obtention et la mutation.</p></div></div></section><section id="_démonstration_6" class="green background"><h2>Démonstration</h2></section><section id="_démonstration_7" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Thing {
  _size = 0;

  get size(): number {
    return this._size;
  }

  set size(value: string | number | boolean) {
    let num = Number(value);

    // Don't allow NaN, Infinity, etc

    if (!Number.isFinite(num)) {
      this._size = 0;
      return;
    }

    this._size = num;
  }
}</code></pre></div></div></div></section></section>
<section><section id="_signatures_dindex" class="blue background"><h2>Signatures d&#8217;index</h2><div class="slide-content"><div class="paragraph"><p>Les classes peuvent déclarer des signatures d&#8217;index. Celles-ci fonctionnenet  de la même façon que les signatures d&#8217;index pour les autres types d&#8217;objet</p></div></div></section><section id="_démonstration_8" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class MyClass {

//s: string  = signature d'index
[s: string]: boolean | ((s: string) =&gt; boolean);

  check(s: string) {
    return this[s] as boolean;
  }
}</code></pre></div></div></div></section><section id="_observations_4" class="yellow background"><h2>Observations</h2><div class="slide-content"><div class="paragraph"><p>Etant donné que le type de la signature d&#8217;index a besoin de capturer les types des méthodes, ce n&#8217;est pas évident d&#8217;utiliser utilement ces types.</p></div>
<div class="paragraph"><p>Généralement il est préférable de conserver les données indexées autre part au lieu de les conserver sur l&#8217;instance elle-même;</p></div></div></section></section>
<section id="_héritage_de_classe" class="blue background"><h2>Héritage de classe</h2><div class="slide-content"><div class="paragraph"><p>Comme dans d&#8217;autres langages avec des caractéristiques orientées objet, les classes en JS peuvent hériter de classes de base</p></div></div></section>
<section><section id="_les_clauses_implements" class="blue background"><h2>Les Clauses implements</h2><div class="slide-content"><div class="paragraph"><p>On peut utiliser une clause implements pour vérifier qu&#8217;une classe satisfait une interface particulière.</p></div><div class="paragraph"><p>Une erreur sera émise si une classe échoie à implémenter correctement l&#8217;interface.</p></div></div></section><section id="_démonstration_9" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">interface Pingable {
  ping(): void;
}

class Sonar implements Pingable {
  ping() {
    console.log("ping!");
  }
}

class Ball implements Pingable {
//Class 'Ball' incorrectly implements interface 'Pingable'.
  //Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.
  pong() {
    console.log("pong!");
  }
}</code></pre></div></div>
<div class="paragraph"><p>Des classes peuvent également implémenter plusieurs interface</p></div></div></section><section id="_prudence" class="yellow background"><h2>Prudence</h2><div class="slide-content"><div class="paragraph"><p>Il est important de comprendre qu&#8217;une clause implements is seulement une vérification qu&#8217;une classe peut être traitée comme le type de l&#8217;interface</p></div>
<div class="paragraph"><p>Cela ne change pas le type de la classe ou ses méthodes.</p></div>
<div class="paragraph"><p>La clause implements ne change pas le type de la classe.</p></div></div></section><section id="_démonstration_10" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">interface Checkable {
  check(name: string): boolean;
}

class NameChecker implements Checkable {
  check(s) {
//Parameter 's' implicitly has an 'any' type.
    // Notice no error here
    return s.toLowerCase() === "ok";

    //any
  }
}</code></pre></div></div></div></section><section id="_observations_5" class="yellow background"><h2>Observations</h2><div class="slide-content"><div class="paragraph"><p>Dans l&#8217;exemple actuel , vous vous étiez peut-être atendu à ce que le type de s soit influé par le paramètre name:string de la fonction check.</p></div>
<div class="paragraph"><p>Alors qu&#8217;en réalité, les clauses implements ne changent pas comment le corps de la classe est vérifié ou comment son type est inféré.</p></div>
<div class="paragraph"><p>Similairement, implémenter une interface avec une propriété optionnelle ne créé par cette propriété.</p></div></div></section><section id="_démonstration_11" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">interface A {
  x: number;
  y?: number;
}
class C implements A {
  x = 0;
}
const c = new C();
c.y = 10;
//Property 'y' does not exist on type 'C'.</code></pre></div></div></div></section></section>
<section><section id="_les_clauses_extends" class="blue background"><h2>Les clauses extends</h2><div class="slide-content"><div class="paragraph"><p>Les classes peuvent être l&#8217;extension d&#8217;une classe de base.</p></div><div class="paragraph"><p>Une classe dérivée a toutes les propriétés et méthodes de sa classe de base et peut aussi définir des membres additionnels.</p></div></div></section><section id="_démonstration_12" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Animal {
  move() {
    console.log("Moving along!");
  }
}

class Dog extends Animal {
  woof(times: number) {
    for (let i = 0; i &lt; times; i++) {
      console.log("woof!");
    }
  }
}

const d = new Dog();
// Base class method
d.move();
// Derived class method
d.woof(3);</code></pre></div></div></div></section></section>
<section><section id="_les_méthodes_de_surcharge_overriding" class="blue background"><h2>Les méthodes de surcharge (overriding)</h2><div class="slide-content"><div class="paragraph"><p>Une classe dérivée peut aussi surcharger  les champs d&#8217;une classe de abse ou une propriété de cette classe de base.</p></div><div class="paragraph"><p>Vous pouvez utiliser la syntaxe super pour accéder méthodes de classe de base.</p></div></div></section><section id="_lookup" class="yellow background"><h2>lookup</h2><div class="slide-content"><div class="paragraph"><p>Il faut noter qu&#8217;étant donné que les classes JS sont simplement des objets de "relation de recherche/référence" (lookup), il n&#8217;existe pas la notion de super champ.</p></div>
<div class="paragraph"><p>TS s&#8217;assure qu&#8217;une classe dérivée est toujours une sous-classe de sa classe de base.</p></div>
<div class="paragraph"><p>Voici un exemple d&#8217;une façon légale de surchargger une méthode :</p></div></div></section><section id="_démonstration_13" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Base {
  greet() {
    console.log("Hello, world!");
  }
}

class Derived extends Base {
  greet(name?: string) {
    if (name === undefined) {
      super.greet();
    } else {
      console.log(`Hello, ${name.toUpperCase()}`);
    }
  }
}

const d = new Derived();
d.greet();
d.greet("reader");</code></pre></div></div>
<div class="paragraph"><p>C&#8217;est important qu&#8217;une classe dérivée suive le contrat de sa classe de base.</p></div>
<div class="paragraph"><p>Rappelez-vous qu&#8217;il est très ordinaire et toujours légal de faire référence à une instance d&#8217;une classe dérivée à travers une référence à la classe de base</p></div></div></section><section id="_démonstration_14" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">// Alias the derived instance through a base class reference
const b: Base = d;
// No problem
b.greet();</code></pre></div></div></div></section><section id="_et_si_derived_na_pas_respecté_le_contrat_de_base"><h2>Et si Derived n&#8217;a pas respecté le contrat de Base ?</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Base {
  greet() {
    console.log("Hello, world!");
  }
}

class Derived extends Base {
  // Make this parameter required
  greet(name: string) {
    //Property 'greet' in type 'Derived' is not assignable to the same property in base type 'Base'.
    //Type '(name: string) =&gt; void' is not assignable to type '() =&gt; void'.
    console.log(`Hello, ${name.toUpperCase()}`);
  }
}

//If we compiled this code despite the error, this sample would then crash:

const b: Base = new Derived();
// Crashes because "name" will be undefined
b.greet();</code></pre></div></div></div></section></section>
<section><section id="_les_déclaration_de_champ_spécial_type" class="blue background"><h2>Les déclaration de champ spécial type</h2><div class="slide-content"><div class="paragraph"><p>Quand target &gt;= ES2022 oui useDefineForClassFields a comme valeur true,</p></div></div></section><section id="_écrasement_des_valeurs_de_la_classe_parent" class="yellow background"><h2>écrasement des valeurs de la classe parent</h2><div class="slide-content"><div class="paragraph"><p>Les champs de classe sont initialisés une fois que le constructueur de la classe parent a fini de s&#8217;exécuter, écrasant toute valeur donnée par la classe parent.</p></div></div></section><section id="_potentiel_problème" class="yellow background"><h2>potentiel problème</h2><div class="slide-content"><div class="paragraph"><p>Cela peut être un problème quand vous voulez simplement re-déclarer de façon plus exacte un type pour un champ hérité.</p></div></div></section><section id="_declare" class="yellow background"><h2>declare</h2><div class="slide-content"><div class="paragraph"><p>Afin de gérer ces cas, vous pouvez écrire "declare" afin d&#8217;indiquer à TS que il ne devrait pas avoir d&#8217;effet "runtime"  pour la déclaration de ce champ.</p></div></div></section><section id="_démonstration_15" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">interface Animal {
  dateOfBirth: any;
}

interface Dog extends Animal {
  breed: any;
}

class AnimalHouse {
  resident: Animal;
  constructor(animal: Animal) {
    this.resident = animal;
  }
}

class DogHouse extends AnimalHouse {
  // Does not emit JavaScript code,
  // only ensures the types are correct
  declare resident: Dog;
  constructor(dog: Dog) {
    super(dog);
  }
}</code></pre></div></div></div></section></section>
<section><section id="_ordre_dinitialisation" class="blue background"><h2>Ordre d&#8217;initialisation</h2><div class="slide-content"><div class="paragraph"><p>L&#8217;ordre dans lequel les classes JS s&#8217;initialisent est parfois surprenant. Regardons ce morceau de code :</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Base {
  name = "base";
  constructor() {
    console.log("My name is " + this.name);
  }
}

class Derived extends Base {
  name = "derived";
}

// Prints "base", not "derived"
const d = new Derived();</code></pre></div></div></div></section><section id="_que_sest_il_passé_ici" class="yellow background"><h2>Que s&#8217;est-il passé ici ?</h2><div class="slide-content"><div class="paragraph"><p>L&#8217;ordre d&#8217;initialisation de classe tel que défini par JS est le suivant :</p></div>
<div class="ulist"><ul><li class="fragment"><p>Les champs de la classe de base sont initialisés</p></li><li class="fragment"><p>Le constructeur de la classe de base s&#8217;exécute</p></li><li class="fragment"><p>Les champs de la classe dérivée sont initialisés</p></li><li class="fragment"><p>Le constructuer de la classe dérivée s&#8217;exécute</p></li></ul></div></div></section><section id="_signification" class="yellow background"><h2>Signification</h2><div class="slide-content"><div class="paragraph"><p>Cela signigie que le constructeur de la classe de base a vu sa propre valeur en tant que nom durant l&#8217;exécution de son constructeur parce que les initialisations des champs de la classe dérivé ne s&#8217;étaient pas encore exécutés.</p></div></div></section></section>
<section><section id="_visibilité_de_membres" class="blue background"><h2>Visibilité de Membres</h2><div class="slide-content"><div class="paragraph"><p>Vous pouvez utiliser TypeScript pour contrôler l’exposition de méthodes et propriétés de la classe vers le code qui lui est externe.</p></div></div></section><section id="_public" class="yellow background"><h2>public</h2><div class="slide-content"><div class="paragraph"><p>La visibilité par défaut de tout membre de classe est public. Il est possible d’accéder à un membre public partout :</p></div></div></section><section id="_démonstration_16" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Greeter {
  public greet() {
    console.log("salut !");
  }
}


const g = new Greeter();
g.greet();</code></pre></div></div>
<div class="paragraph"><p>Parce que public est déjà la visibilité par défaut, vous n’avez pas besoin de le préciser pour un membre de classe, mais vous pourriez toujours le faire pour des raisons de lisibilité / style de code.</p></div></div></section><section id="_protected" class="yellow background"><h2>protected</h2><div class="slide-content"><div class="paragraph"><p>Les membres protected ne sont visibles que dans la classe qui les a déclarés.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Greeter {
  public greet() {
    console.log("Bonjour, " + this.getName());
  }
  protected getName() {
    return "hi";
  }
}</code></pre></div></div>
<div class="paragraph"><p>class SpecialGreeter extends Greeter {
  public howdy() {
    // On peut accéder à this.getName ici
    console.log("Yo, " + this.getName());
  }
}
const g = new SpecialGreeter();
g.greet(); // OK
g.getName();</p></div>
<div class="paragraph"><p>Property 'getName' is protected and only accessible within class 'Greeter' and its subclasses.
Try</p></div></div></section><section id="_exposition_des_membres_protected" class="yellow background"><h2>Exposition des membres protected</h2><div class="slide-content"><div class="paragraph"><p>Les classes dérivées doivent suivre les contrats de leurs classes de base, mais peuvent exposer un sous-type qui a plus de possibilités qu’une classe-mère. Ainsi, il est possible de donner une visibilité public à des membres protected à l’origine :</p></div></div></section><section id="_démonstration_17" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Base {
  protected m = 10;
}
class Derived extends Base {
  // Pas de modificateur, le "public" par défaut s'applique
  m = 15;
}
const d = new Derived();
console.log(d.m); // OK</code></pre></div></div>
<div class="paragraph"><p>Remarquez que Derived est quand même capable de lire et d’écrire m, donc protéger m n’aura servi à rien. Si vous voulez rendre la propriété protected dans la classe dérivée également, vous devrez répéter le mot-clé protected.</p></div></div></section><section id="_accès_aux_membres_protected_entre_classes_mères_et_dérivées" class="yellow background"><h2>Accès aux membres protected entre classes mères et dérivées</h2><div class="slide-content"><div class="paragraph"><p>Les langages OOP différents ne s’accordent pas si un membre qui est protected est toujours accessible aux classes dérivées :</p></div></div></section><section id="_démonstration_18" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Base {
  protected x: number = 1;
}
class Derived1 extends Base {
  protected x: number = 5;
}
class Derived2 extends Base {
  f1(other: Derived2) {
    other.x = 10;
  }
  f2(other: Base) {
    other.x = 10;
//Property 'x' is protected and only accessible through an instance of class 'Derived2'. This is an instance of 'Base'.
  }
}</code></pre></div></div></div></section><section id="_java" class="yellow background"><h2>Java</h2><div class="slide-content"><div class="paragraph"><p>Java considère cette manipulation légale, au contraire du C++ et du C#.</p></div></div></section><section id="_ts" class="yellow background"><h2>TS</h2><div class="slide-content"><div class="paragraph"><p>TypeScript se range du côté du C# et C++ dans ce débat.</p></div>
<div class="paragraph"><p>Accéder à x dans Derived2 doit être légal uniquement à partir de sous-classes de Derived2, ce qui n’est pas le cas de Derived1. De plus, si l’accès à x à travers une Derived1 est illégal pour des raisons évidentes, alors tenter d’y accéder à travers Base ne doit rien y changer.</p></div>
<div class="paragraph"><p>Voir aussi Why Can’t I Access A Protected Member From A Derived Class? qui explique le raisonnement derrière cette interdiction en C#.</p></div></div></section><section id="_private" class="yellow background"><h2>private</h2><div class="slide-content"><div class="paragraph"><p>private ressemble à protected, mais interdit tout accès à la propriété depuis autre chose que la classe elle-même (cela exclut donc les classes dérivées):</p></div></div></section><section id="_démonstration_19" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Base {
  protected x: number = 1;
}
class Derived1 extends Base {
  protected x: number = 5;
}
class Derived2 extends Base {
  f1(other: Derived2) {
    other.x = 10;
  }
  f2(other: Base) {
    other.x = 10;
//Property 'x' is protected and only accessible through an instance of class 'Derived2'. This is an instance of class 'Base'.
  }
}


class Base {
  private x = 0;
}
const b = new Base();
// Can't access from outside the class
console.log(b.x);
Property 'x' is private and only accessible within class 'Base'.
Try
class Derived extends Base {
  showX() {
    // Can't access in subclasses
    console.log(this.x);
//Property 'x' is private and only accessible within class 'Base'.
  }
}</code></pre></div></div>
<div class="paragraph"><p>Une classe dérivée ne peut pas modifier la visibilité d’un membre private, vu qu’elle ne le voit même pas :</p></div></div></section><section id="_démonstration_20" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Base {
  private x = 0;
}
class Derived extends Base {

//Class 'Derived' incorrectly extends base class 'Base'.
  //Property 'x' is private in type 'Base' but not in type 'Derived'.
  x = 1;
}</code></pre></div></div></div></section><section id="_accès_à_un_membre_private_entre_différentes_instances" class="yellow background"><h2>Accès à un membre private entre différentes instances</h2><div class="slide-content"><div class="paragraph"><p>Les langages OOP différents ne s’accordent pas si les instances d’une même classe peuvent accéder à leurs membres privés respectifs. Java, C#, C++, Swift, et PHP le permettent, Ruby l’interdit.</p></div>
<div class="paragraph"><p>TypeScript le permet :</p></div></div></section><section id="_démonstration_21" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class A {
private x = 10;

public sameAs(other: A) {
  // No error
  return other.x === this.x;
}
}</code></pre></div></div></div></section><section id="_considérations" class="yellow background"><h2>Considérations</h2><div class="slide-content"><div class="paragraph"><p>Comme d’autres aspects de TypeScript, private et protected sont uniquement imposés pendant la compilation.</p></div>
<div class="paragraph"><p>Cela signifie que des expressions JavaScript in ou une simple lecture de propriétés peuvent accéder à un membre private ou protected :</p></div></div></section><section id="_démonstration_22" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class MySafe {
  private secretKey = 12345;
}


// Dans un fichier JavaScript, va afficher 12345
const s = new MySafe();
console.log(s.secretKey);</code></pre></div></div>
<div class="paragraph"><p>private permet également d’accéder à la propriété avec la notation à crochets. Cela permet de faciliter l’accès aux propriétés private pour, par exemple, les tests unitaires. Le défaut dans cette approche est que ces propriétés ne sont donc pas complètement private.</p></div></div></section><section id="_démonstration_23" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class MySafe {
  private secretKey = 12345;
}

const s = new MySafe();

// Interdit durant la vérification
console.log(s.secretKey);</code></pre></div></div></div></section><section id="_démonstration_24" class="yellow background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">console.log(s["secretKey"]);</code></pre></div></div>
<div class="paragraph"><p>Les variables de classes privées (#) resteront privées après compilation et représentent une approche plus stricte aux champs privés, interdisant les contournements disponibles avec le mot-clé private.</p></div></div></section><section id="_démonstration_25" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Dog {
  #barkAmount = 0;
  personality = "happy";

  constructor() {}
}
Try
"use strict";
class Dog {
    #barkAmount = 0;
    personality = "happy";
    constructor() { }
}</code></pre></div></div>
<div class="paragraph"><p>En compilant vers ES2021 ou inférieur, TypeScript va utiliser des WeakMaps à la place de #.</p></div></div></section><section id="_démonstration_26" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">"use strict";
var _Dog_barkAmount;
class Dog {
    constructor() {
        _Dog_barkAmount.set(this, 0);
        this.personality = "happy";
    }
}
_Dog_barkAmount = new WeakMap();</code></pre></div></div>
<div class="paragraph"><p>Si vous avez besoin de protéger vos valeurs de classes contre les acteurs malicieux, vous devez vous servir de mécanismes offrant de la sécurité stricte durant l’exécution, tel que les closures, WeakMaps, ou les champs privés. Remarquez que ces mesures additionnelles peuvent affecter la performance.</p></div></div></section></section>
<section><section id="_membres_statiques" class="blue background"><h2>Membres statiques</h2><div class="slide-content"><div class="paragraph"><p>Les Classes peuvent avoir des membres static. Ces membres ne sont pas associés à une instance particulière d’une classe, et peuvent être lus depuis le constructeur de la classe elle-même :</p></div></div></section><section id="_démonstration_27" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class MyClass {
  static x = 0;
  static printX() {
    console.log(MyClass.x);
  }
}
console.log(MyClass.x);
MyClass.printX();</code></pre></div></div>
<div class="paragraph"><p>Les membres static peuvent avoir les mêmes modificateurs public, protected, et private :</p></div></div></section><section id="_démonstration_28" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class MyClass {
  private static x = 0;
}
console.log(MyClass.x);
//Property 'x' is private and only accessible within class 'MyClass'.</code></pre></div></div>
<div class="paragraph"><p>Les membres static peuvent être hérités par les classes dérivées :</p></div></div></section><section id="_démonstration_29" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Base {
  static getGreeting() {
    return "Hello world";
  }
}
class Derived extends Base {
  myGreeting = Derived.getGreeting();
}</code></pre></div></div></div></section><section id="_noms_spéciaux_de_propriétés_statiques" class="yellow background"><h2>Noms spéciaux de propriétés statiques</h2><div class="slide-content"><div class="paragraph"><p>Généralement, il n’est pas sûr / possible d’écrire sur des propriétés du prototype de Function. Les classes sont elles-mêmes des fonctions qui peuvent être invoquées avec new. Donc certaines propriétés static ne peuvent pas être utilisées. Les propriétés name, length, et call ne peuvent pas être définies en tant que membres static :</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class S {
  static name = "S!";
//Static property 'name' conflicts with built-in property 'Function.name' of constructor function 'S'.
}</code></pre></div></div></div></section><section id="_pourquoi_pas_des_classes_statiques" class="yellow background"><h2>Pourquoi pas des classes statiques ?</h2><div class="slide-content"><div class="paragraph"><p>TypeScript (et JavaScript) n’ont pas de classes statiques, de la même façon que, par exemple, C#.</p></div>
<div class="paragraph"><p>Ces structures n’existent que parce que ces langages obligent toutes les données et fonctions à être à l’intérieur de classes. Elles n’ont aucun intérêt à être dans TypeScript ou JavaScript, ces deux langages n’ayant pas cette restriction. Une classe qui n’a qu’une seule instance est parfois représentée simplement par un objet normal.</p></div>
<div class="paragraph"><p>Une classe statique n’est pas nécessaire car elle peut très bien se substituer à un objet ou une fonction :</p></div></div></section><section id="_démonstration_30" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">// Classe statique non nécessaire
class MyStaticClass {
  static doSomething() {}
}

// 1ère alternative privilégiée
function doSomething() {}

// 2ème alternative privilégiée
const MyHelperObject = {
  dosomething() {},
};</code></pre></div></div></div></section><section id="_blocs_statiques_dans_une_classe" class="yellow background"><h2>Blocs statiques dans une classe</h2><div class="slide-content"><div class="paragraph"><p>Les blocs statiques vous permettent d’écrire des déclarations avec leur propre portée. Cette portée peut lire les champs privés dans la classe qui les contient. Cela signifie que l’on peut écrire ce qu’on veut en termes de code, sans fuite de variables vers l’extérieur, et avec accès complet aux propriétés et méthodes de la classe.</p></div></div></section><section id="_démonstration_31" class="yellow background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Foo {
    static #count = 0;

    get count() {
        return Foo.#count;
    }

    static {
        try {
            const lastInstances = loadLastInstances();
            Foo.#count += lastInstances.length;
        }
        catch {}
    }
}</code></pre></div></div></div></section></section>
<section><section id="_les_classes_génériques_section_placée_ailleurs" class="blue background"><h2>Les Classes génériques ( section placée ailleurs )</h2></section><section id="_this_à_lexécution_dans_les_classes" class="yellow background"><h2>this à l’exécution dans les classes</h2><div class="slide-content"><div class="paragraph"><p>TypeScript ne change pas le comportement de JavaScript à l’exécution, et JavaScript est célèbre pour ses comportements très particuliers à l’exécution.</p></div>
<div class="paragraph"><p>Cela inclut l’opérateur this :</p></div></div></section><section id="_démonstration_32" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class MyClass {
  name = "MyClass";
  getName() {
    return this.name;
  }
}
const c = new MyClass();
const obj = {
  name: "obj",
  getName: c.getName,
};

// Affiche "obj", pas "MyClass"
console.log(obj.getName());</code></pre></div></div>
<div class="paragraph"><p>Pour résumer, par défaut, la valeur de this à l’intérieur d’une fonction dépend de comment la fonction a été appelée. Dans cet exemple, parce que cette fonction a été appelée avec une référence à obj, la valeur de this était obj au lieu d’être l’instance de classe.</p></div>
<div class="paragraph"><p>C’est rarement le comportement que vous désirez ! TypeScript fournit plusieurs façons de remédier à ce problème.</p></div></div></section></section>
<section><section id="_les_fonctions_fléchées" class="blue background"><h2>Les fonctions fléchées</h2><div class="slide-content"><div class="paragraph"><p>Si vous avez une fonction qui sera souvent appelée d&#8217;une façon où elle perd son contexte "this", alors à ce moment-là ça peut être sensé d&#8217;utiliser une fonction fléchée au lieu d&#8217;une définition de méthode.</p></div></div></section><section id="_démonstration_33" class="yellow background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class MyClass {
  name = "MyClass";
  getName = () =&gt; {
    return this.name;
  };
}

const c = new MyClass();
const g = c.getName;
// Prints "MyClass" instead of crashing
console.log(g());</code></pre></div></div></div></section></section>
<section id="_les_limites_dune_fonction_fléchée" class="blue background"><h2>Les limites d&#8217;une fonction fléchée</h2><div class="slide-content"><div class="ulist"><ul><li class="fragment"><p>La valeur this is garantie d&#8217;être correcte au moment de l&#8217;exécution de programme, même pour le code qui n&#8217;a pas été vérifié par TS</p></li><li class="fragment"><p>Cela va occassionner une plus grande utilisation de la mémoire car chaque instance de la classe aura sa propre copie de chaque fonction définie de cette façon.</p></li><li class="fragment"><p>On ne peut pas utiliser super.getName dans une classe dérivée, parce qu&#8217;il n&#8217;y a pas d&#8217;entrée dans la chaîne prototypique pour aller cherche la méthode de la classe de base depuis les paramètres de "this".</p></li></ul></div></div></section>
<section><section id="_le_paramètre_this_en_ts" class="blue background"><h2>le paramètre this en TS</h2><div class="slide-content"><div class="paragraph"><p>Dans une définition de méthode ou de fonction, un paramètre intiial nommé this a un sens spécial en TS. Cas paramètres sont effacés durant le compilation.</p></div></div></section><section id="_démonstration_34" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">// TypeScript input with 'this' parameter
function fn(this: SomeType, x: number) {
  /* ... */
}

// JavaScript output
function fn(x) {
  /* ... */
}</code></pre></div></div>
<div class="paragraph"><p>TS vérifie si l&#8217;appel a une fonction avec un paramètre this est fait dans un contexte approprié. Au lieu d&#8217;utiliser une fonction fléché, on peut ajouter un paramètre this aux définitions de méthode pour faire en sorte de façon statique que la méthode est appelée correctement.</p></div></div></section><section id="_démonstration_35" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class MyClass {
  name = "MyClass";
  getName(this: MyClass) {
    return this.name;
  }
}
const c = new MyClass();
// OK
c.getName();

// Error, would crash
const g = c.getName;
console.log(g());
//The 'this' context of type 'void' is not assignable to method's 'this' of type 'MyClass'.</code></pre></div></div></div></section><section id="_limites_de_lapproche_avec_le_paramètre_this" class="yellow background"><h2>Limites de l&#8217;approche avec le paramètre this</h2><div class="slide-content"><div class="ulist"><ul><li class="fragment"><p>Les appelants de JS pourraient encore utiliser la méthode de classe de façon incorrecte sans s&#8217;en rendre compte.</p></li><li class="fragment"><p>Seulement une fonction par définition de classe serait allouée, au lieu d&#8217;une par instance de classe</p></li><li class="fragment"><p>Les définitions des méthodes Base peuent être appelées via super.</p></li></ul></div></div></section></section>
<section><section id="_le_type_this_en_ts" class="blue background"><h2>Le type this en TS</h2><div class="slide-content"><div class="paragraph"><p>Dans les classes,un type spécial appelé this fait référence dynamiquement au type de la classe actuelle.</p></div></div></section><section id="_démonstration_36" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Box {
  contents: string = "";
  set(value: string) {

    //(method) Box.set(value: string): this
    this.contents = value;
    return this;
  }
}

// En l'occurence, TS déduit le type de la valeur retournée comme étant this, plus que Box. Mettons faisons une sous-classe de Box.
class ClearableBox extends Box {
  clear() {
    this.contents = "";
  }
}

const a = new ClearableBox();
const b = a.set("hello");

const b: ClearableBox</code></pre></div></div>
<div class="paragraph"><p>Vous pouvez également utiliser this dans une annotation de type de paramètre</p></div></div></section><section id="_démonstration_37" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Box {
  content: string = "";
  sameAs(other: this) {
    return other.content === this.content;
  }
}</code></pre></div></div>
<div class="paragraph"><p>Cela est différant d&#8217;écrire other:Box . Si vous avez une classe dérivée, sa méthode sameAs n&#8217;acceptera maintenant que d&#8217;autres instances de cette même classe dérivée.</p></div></div></section><section id="_démonstration_38" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Box {
  content: string = "";
  sameAs(other: this) {
    return other.content === this.content;
  }
}

class DerivedBox extends Box {
  otherContent: string = "?";
}

const base = new Box();
const derived = new DerivedBox();
derived.sameAs(base);
//Argument of type 'Box' is not assignable to parameter of type 'DerivedBox'.
  //Property 'otherContent' is missing in type 'Box' but required in type 'DerivedBox'.</code></pre></div></div></div></section></section>
<section><section id="_les_gardes_de_type_basées_sur_this" class="blue background"><h2>les gardes de type basées sur this</h2><div class="slide-content"><div class="paragraph"><p>Vous pouvez utiliser "this is Type" dans la position return pour les méthodes dans les classes et interfaces.</p></div><div class="paragraph"><p>Quand c&#8217;est melangé avec un rétrécissement de type ( dans les déclarations if) le type de l&#8217;objet cible sera réduit à ce type spécifique.</p></div></div></section><section id="_démonstration_39" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class FileSystemObject {
  isFile(): this is FileRep {
    return this instanceof FileRep;
  }
  isDirectory(): this is Directory {
    return this instanceof Directory;
  }
  isNetworked(): this is Networked &amp; this {
    return this.networked;
  }
  constructor(public path: string, private networked: boolean) {}
}

class FileRep extends FileSystemObject {
  constructor(path: string, public content: string) {
    super(path, false);
  }
}

class Directory extends FileSystemObject {
  children: FileSystemObject[];
}

interface Networked {
  host: string;
}

const fso: FileSystemObject = new FileRep("foo/bar.txt", "foo");

if (fso.isFile()) {
  fso.content;

const fso: FileRep
} else if (fso.isDirectory()) {
  fso.children;

const fso: Directory
} else if (fso.isNetworked()) {
  fso.host;

const fso: Networked &amp; FileSystemObject
}</code></pre></div></div>
<div class="paragraph"><p>Un usage courant pour les gardes de types basés sur this est d&#8217;accepter la validations "lazy" d&#8217;un champ particulier
Par exemple, ce cas enlève un "undefined" des valeurs contenus à l&#8217;intérieur de la box when hasValue a été vérifié comme étant "true"</p></div></div></section><section id="_démonstration_40" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">class Box&lt;T&gt; {
  value?: T;

  hasValue(): this is { value: T } {
    return this.value !== undefined;
  }
}

const box = new Box();
box.value = "Gameboy";

box.value;

(property) Box&lt;unknown&gt;.value?: unknown

if (box.hasValue()) {
  box.value;

(property) value: unknown
}</code></pre></div></div></div></section></section>
<section><section id="_les_propriétés_paramètres" class="blue background"><h2>Les propriétés paramètres :</h2><div class="slide-content"><div class="paragraph"><p>TS offre une syntaxe spéciale pour transformer un paramètre de constructeur en une propriété de classe avec le même nom et la même valeur. On appelle ça les propriétés paramètres et sont crées en préfixant un argument de constructeur avec un modificateur de visibilité suivant : public, private et readonly.</p></div><div class="paragraph"><p>Le champ qui en résult obtient ces modificateurs</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {
    // No body necessary
  }
}
const a = new Params(1, 2, 3);
console.log(a.x);

//(property) Params.x: number

console.log(a.z);
//Property 'z' is private and only accessible within class 'Params'.</code></pre></div></div></div></section><section id="_les_expression_de_classe" class="yellow background"><h2>Les Expression de classe</h2><div class="slide-content"><div class="paragraph"><p>Les expressions de classe sont très similaires aux déclarations de classe.</p></div>
<div class="paragraph"><p>La seule vraie différence est que les expressions de classe n&#8217;ont pas beesoin d&#8217;un nom, bien qu&#8217;on puisse s&#8217;y référer via l&#8217;identifiant auquel elles sont liées.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-typeScript" data-lang="typeScript">const someClass = class&lt;Type&gt; {
  content: Type;
  constructor(value: Type) {
    this.content = value;
  }
};

const m = new someClass("Hello, world");

const m: someClass&lt;string&gt;</code></pre></div></div></div></section><section id="_constructor_signatures" class="yellow background"><h2>Constructor Signatures</h2><div class="slide-content"><div class="paragraph"><p>Les classes JS sont instanciées avec l&#8217;opérateur new. Etant donné le type de la classe elle-même, le type utilitaire InstanceType donne le modèle type de cette opération.</p></div></div></section><section id="_démonstration_41" class="yellow background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Point {
  createdAt: number;
  x: number;
  y: number

  constructor(x: number, y: number) {
    this.createdAt = Date.now()
    this.x = x;
    this.y = y;
  }
}
type PointInstance = InstanceType&lt;typeof Point&gt;

function moveRight(point: PointInstance) {
  point.x += 5;
}

const point = new Point(3, 4);
moveRight(point);
point.x; // =&gt; 8</code></pre></div></div></div></section></section>
<section><section id="_abstract" class="blue background"><h2>abstract</h2><div class="slide-content"><div class="paragraph"><p>Les classes, les méthodes et les champs en TypeScript peuvent être abstraits.</p></div></div></section><section id="_définition" class="yellow background"><h2>Définition</h2><div class="slide-content"><div class="paragraph"><p>Une méthode abstraite ou un champ abstrait est celui qui n&#8217;a pas d&#8217;implémentation fournie.</p></div>
<div class="paragraph"><p>Ces membres doivent exister à l&#8217;intérieur d&#8217;une classe abstraite, qui ne peut être directement instanciée.</p></div></div></section><section id="_rôle" class="yellow background"><h2>Rôle</h2><div class="slide-content"><div class="paragraph"><p>Le rôle des classes abstraites est de servir comme de classe de base pour des sous-classes qui elles implémentent les membres abstraits.</p></div></div></section><section id="_exemple_3" class="green background"><h2>Exemple</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">abstract class Base {
  abstract getName(): string;

  printName() {
    console.log("Hello, " + this.getName());
  }
}

const b = new Base();
//Cannot create an instance of an abstract class.</code></pre></div></div>
<div class="paragraph"><p>On ne peut pas instancier Base avec new parce qu&#8217;elle est abstraite. On a besoin de faire une classe dérivée et d&#8217;implémentter les membres abstraits.</p></div></div></section><section id="_démonstration_42" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Derived extends Base {
  getName() {
    return "world";
  }
}

const d = new Derived();
d.printName();</code></pre></div></div>
<div class="paragraph"><p>Si on oublie d&#8217;implémenter les membres abstraits de la classe de base , on aura une erreur.</p></div>
<div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Derived extends Base {

//Non-abstract class 'Derived' does not implement inherited abstract member 'getName' from class 'Base'.
  // forgot to do anything
}</code></pre></div></div></div></section><section id="_signatures_de_construction_abstraite" class="yellow background"><h2>Signatures de construction abstraite</h2><div class="slide-content"><div class="paragraph"><p>Parfois vous voulez accepter une function constructrice de classe qui produits une instance d&#8217;une classe qui dérive d&#8217;une classe abstraite.</p></div></div></section><section id="_exemple_4" class="green background"><h2>Exemple</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">function greet(ctor: typeof Base) {

  const instance = new ctor();

//Cannot create an instance of an abstract class.
  instance.printName();
}</code></pre></div></div>
<div class="paragraph"><p>TS est en train de vous dire que vous êtes en train d&#8217;essayer d&#8217;instancier une classe abstraite.
Après tout, étant donné la définition de greet, c&#8217;est parfait légal d&#8217;écrire ce code, qui reviendrait à construire une classe abstraite.</p></div></div></section><section id="_démonstration_43" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">// Bad!
greet(Base);</code></pre></div></div>
<div class="paragraph"><p>Au lieu de cela, vous voulez écrire une fonction qui accepte quelquechose ayant une signature de construction</p></div></div></section><section id="_démonstration_44" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">function greet(ctor: new () =&gt; Base) {
  const instance = new ctor();
  instance.printName();
}
greet(Derived);
greet(Base);

//Argument of type 'typeof Base' is not assignable to parameter of type 'new () =&gt; Base'.
  //Cannot assign an abstract constructor type to a non-abstract constructor type.</code></pre></div></div>
<div class="paragraph"><p>Maintenant TS vous dit à juste titre quelle fonction de constructeur de classe peut être invoquée, en l&#8217;occurrence c&#8217;est le cas de Derived parce qu&#8217;elle est une classe concrète, mais ce n&#8217;est pas le cas de Base</p></div></div></section></section>
<section><section id="_relations_entre_les_classes" class="blue background"><h2>Relations entre les classes</h2><div class="slide-content"><div class="paragraph"><p>Dans la plupart des cas, les classes en TS sont comparées structurellement, comme les autres types</p></div><div class="paragraph"><p>Par exemple, ces deux classes peuvent être utilisées à la place de l&#8217;une et de l&#8217;autre parce qu&#8217;elles sont identiques.</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Point1 {
  x = 0;
  y = 0;
}

class Point2 {
  x = 0;
  y = 0;
}

// OK
const p: Point1 = new Point2();</code></pre></div></div><div class="paragraph"><p>De manière semblable, les relations de sous-type entre les classes existent même si il n&#8217;y a pas d&#8217;héritage explicite.</p></div><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">class Person {
  name: string;
  age: number;
}

class Employee {
  name: string;
  age: number;
  salary: number;
}

// OK
const p: Person = new Employee();</code></pre></div></div></div></section><section id="_le_cas_de_classe_vide" class="yellow background"><h2>Le cas de classe vide</h2><div class="slide-content"><div class="paragraph"><p>Les classes vident n&#8217;ont pas de membres. Dans un système de type structurel , un type avec aucun membre est généralement un super type de quelque chose d&#8217;autre. Donc si vous écrivez une classe vide et je ne vous le conseille pas, n&#8217;importe quoi peut être utilisé à sa place.</p></div></div></section><section id="_démonstration_45" class="green background"><h2>Démonstration</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlight"><code class="language-javascript" data-lang="javascript">---
class Empty {}</code></pre></div></div>
<div class="paragraph"><p>function fn(x: Empty) {
  // can&#8217;t do anything with 'x', so I won&#8217;t
}</p></div>
<div class="paragraph"><p>fn(window);
fn({});
fn(fn);
---</p></div></div></section></section>
<section id="_le_modificateur_de_classe_public_private_readonly" class="blue background"><h2>Le modificateur de classe : "public, private, readonly"</h2><div class="slide-content"><div class="paragraph"><p>Vu précédemment</p></div></div></section>
<section id="_les_méthodes_private_protected_overrides" class="blue background"><h2>Les méthodes : "private, protected, overrides"</h2><div class="slide-content"><div class="paragraph"><p>Vu précédemment</p></div></div></section>
<section id="_lhéritage_simple_multiple" class="blue background"><h2>L&#8217;héritage simple, multiple</h2><div class="slide-content"><div class="paragraph"><p>Vu précédemment</p></div></div></section></div></div><script src="node_modules/reveal.js/dist/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
});

// More info about config & dependencies:
// - https://github.com/hakimel/reveal.js#configuration
// - https://github.com/hakimel/reveal.js#dependencies
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Add the current slide number to the URL hash so that reloading the
  // page/copying the URL will return you to the same slide
  hash: false,
  // Push each slide change to the browser history. Implies `hash: true`
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Disables the default reveal.js slide layout so that you can use custom CSS layout
  disableLayout: false,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // See https://github.com/hakimel/reveal.js/#navigation-mode
  navigationMode: 'default',
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Global override for preloading lazy-loaded iframes
  // - null: Iframes with data-src AND data-preload will be loaded when within
  //   the viewDistance, iframes with only data-src will be loaded when visible
  // - true: All iframes with data-src will be loaded when within the viewDistance
  // - false: All iframes with data-src will be loaded only when visible
  preloadIframes: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Specify the total time in seconds that is available to
  // present.  If this is set to a nonzero value, the pacing
  // timer will work out the time available for each slide,
  // instead of using the defaultTiming value
  totalTime: 0,
  // Specify the minimum amount of time you want to allot to
  // each slide, if using the totalTime calculation method.  If
  // the automated time allocation causes slide pacing to fall
  // below this threshold, then you will see an alert in the
  // speaker notes window
  minimumTimePerSlide: 0,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hide cursor if inactive
  hideInactiveCursor: true,
  // Time before the cursor is hidden (in ms)
  hideCursorTime: 5000,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Number of slides away from the current that are visible on mobile
  // devices. It is advisable to set this to a lower number than
  // viewDistance in order to save resources.
  mobileViewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // PDF Export Options
  // Put each fragment on a separate page
  pdfSeparateFragments: true,
  // For slides that do not fit on a page, max number of pages
  pdfMaxPagesPerSlide: 1,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'node_modules/reveal.js/plugin/zoom/zoom.js', async: true, callback: function () { Reveal.registerPlugin(RevealZoom) } },
      { src: 'node_modules/reveal.js/plugin/notes/notes.js', async: true, callback: function () { Reveal.registerPlugin(RevealNotes) } }
  ],
});</script><script>var dom = {};
dom.slides = document.querySelector('.reveal .slides');

function getRemainingHeight(element, slideElement, height) {
  height = height || 0;
  if (element) {
    var newHeight, oldHeight = element.style.height;
    // Change the .stretch element height to 0 in order find the height of all
    // the other elements
    element.style.height = '0px';
    // In Overview mode, the parent (.slide) height is set of 700px.
    // Restore it temporarily to its natural height.
    slideElement.style.height = 'auto';
    newHeight = height - slideElement.offsetHeight;
    // Restore the old height, just in case
    element.style.height = oldHeight + 'px';
    // Clear the parent (.slide) height. .removeProperty works in IE9+
    slideElement.style.removeProperty('height');
    return newHeight;
  }
  return height;
}

function layoutSlideContents(width, height) {
  // Handle sizing of elements with the 'stretch' class
  toArray(dom.slides.querySelectorAll('section .stretch')).forEach(function (element) {
    // Determine how much vertical space we can use
    var limit = 5; // hard limit
    var parent = element.parentNode;
    while (parent.nodeName !== 'SECTION' && limit > 0) {
      parent = parent.parentNode;
      limit--;
    }
    if (limit === 0) {
      // unable to find parent, aborting!
      return;
    }
    var remainingHeight = getRemainingHeight(element, parent, height);
    // Consider the aspect ratio of media elements
    if (/(img|video)/gi.test(element.nodeName)) {
      var nw = element.naturalWidth || element.videoWidth, nh = element.naturalHeight || element.videoHeight;
      var es = Math.min(width / nw, remainingHeight / nh);
      element.style.width = (nw * es) + 'px';
      element.style.height = (nh * es) + 'px';
    } else {
      element.style.width = width + 'px';
      element.style.height = remainingHeight + 'px';
    }
  });
}

function toArray(o) {
  return Array.prototype.slice.call(o);
}

Reveal.addEventListener('slidechanged', function () {
  layoutSlideContents(960, 700)
});
Reveal.addEventListener('ready', function () {
  layoutSlideContents(960, 700)
});
Reveal.addEventListener('resize', function () {
  layoutSlideContents(960, 700)
});</script></body></html>